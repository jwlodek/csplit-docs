{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"csplit A single header C library that can be used to easily handle splitting strings and other string operations in C. Why does it exist? I wrote csplit because I found string manipulation in C to be very difficult, particularly the strtok built in function. I have successfully used csplit in several projects, primarily for parsing input files, and I hope it proves to be of use to you. What is it? csplit is intended to be a C string manipulation library that attempts to have a similar syntax as pythonic string functions. For example, passing a negative index into a csplit function will simply perform whatever operation was selected starting from the rearmost index. The primary usage for csplit is as a replacement for strtok , though it also includes several other string manipulation functions. For my use cases, I have used csplit for parsing .csv files, custom CONFIGURE files I write, and other things. csplit was written as a single header C library to simplify it's inclusion into other projects I have written. This may not be the most efficient way of writing this, seeing as csplit does contain quite a few functions, but I found that this implementation made using it for the small projects I work on that require some string manipulation to be much easier. Usage The core functions that csplit provides are the following: CSplitError_t csplit(CSplitList_t* list, char* input_str, char* token); This will split the input string based on the token, as many times as possible. You may also limit the number of splits with: CSplitError_t csplit_lim(CSplitList_t* list, char* input_str, char* token, int max_splits); where max_splits is the maximum number of splits allowed. If max_splits is negative, csplit will perform the splits from the end of the string first, instead of from the front. In order to use these core functions, we must first initialize a CSplitList_t struct: CSplitList_t* list = csplit_init_list(); This will create a doubly linked list data structure that will be used to internally store the split string fragments. Once this struct is allocated, we may call one of the csplit core functions listed above. This will populate the linked list with CSplitFragment_t structures that contain the string fragments found by splitting. In order to access these fragments, we can use the char* csplit_get_fragment_at_index(CSplitList_t* list, int index); function. Once again, as is the case in python, passing a negative number will net the string fragment starting from the rear of the list. For example, an index of -1 would be the last fragment, -2 would be the second to last fragment, etc. Once we are done with the split fragments and our list, we must free up the memory associated with it: void csplit_clear_list(CSplitList_t* list); For more detailed sample code using the csplit library, make sure to take a look at the Examples tab of this documentation.","title":"Home"},{"location":"#csplit","text":"A single header C library that can be used to easily handle splitting strings and other string operations in C.","title":"csplit"},{"location":"#why-does-it-exist","text":"I wrote csplit because I found string manipulation in C to be very difficult, particularly the strtok built in function. I have successfully used csplit in several projects, primarily for parsing input files, and I hope it proves to be of use to you.","title":"Why does it exist?"},{"location":"#what-is-it","text":"csplit is intended to be a C string manipulation library that attempts to have a similar syntax as pythonic string functions. For example, passing a negative index into a csplit function will simply perform whatever operation was selected starting from the rearmost index. The primary usage for csplit is as a replacement for strtok , though it also includes several other string manipulation functions. For my use cases, I have used csplit for parsing .csv files, custom CONFIGURE files I write, and other things. csplit was written as a single header C library to simplify it's inclusion into other projects I have written. This may not be the most efficient way of writing this, seeing as csplit does contain quite a few functions, but I found that this implementation made using it for the small projects I work on that require some string manipulation to be much easier.","title":"What is it?"},{"location":"#usage","text":"The core functions that csplit provides are the following: CSplitError_t csplit(CSplitList_t* list, char* input_str, char* token); This will split the input string based on the token, as many times as possible. You may also limit the number of splits with: CSplitError_t csplit_lim(CSplitList_t* list, char* input_str, char* token, int max_splits); where max_splits is the maximum number of splits allowed. If max_splits is negative, csplit will perform the splits from the end of the string first, instead of from the front. In order to use these core functions, we must first initialize a CSplitList_t struct: CSplitList_t* list = csplit_init_list(); This will create a doubly linked list data structure that will be used to internally store the split string fragments. Once this struct is allocated, we may call one of the csplit core functions listed above. This will populate the linked list with CSplitFragment_t structures that contain the string fragments found by splitting. In order to access these fragments, we can use the char* csplit_get_fragment_at_index(CSplitList_t* list, int index); function. Once again, as is the case in python, passing a negative number will net the string fragment starting from the rear of the list. For example, an index of -1 would be the last fragment, -2 would be the second to last fragment, etc. Once we are done with the split fragments and our list, we must free up the memory associated with it: void csplit_clear_list(CSplitList_t* list); For more detailed sample code using the csplit library, make sure to take a look at the Examples tab of this documentation.","title":"Usage"},{"location":"about/","text":"About csplit Author Jakub Wlodek Created on August 02, 2019 License MIT License Copyright (c) 2019 Jakub Wlodek Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"About"},{"location":"about/#about-csplit","text":"","title":"About csplit"},{"location":"about/#author","text":"Jakub Wlodek Created on August 02, 2019","title":"Author"},{"location":"about/#license","text":"MIT License Copyright (c) 2019 Jakub Wlodek Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"examples/","text":"csplit Usage Examples To build csplit examples, enter the examples directory, and run: make clean all or make clean debug to have access to gdb debugging of the examples. This has been tested on linux, as well as on Windows with gcc and make included in MinGW. Basic Example Example demonstrating using csplit for splitting string on single character and getting split fragments based on indexes. // include csplit and stdio #include \"csplit.h\" #include <stdio.h> int main(int argc, char** argv){ // our test string char* test_string = \"Hello how are you doing?\"; printf(\"Our demo string is: %s\\n\", test_string); // initialize our output list CSplitList_t* list = csplit_init_list(); // split on the \" \" (space) character CSplitError_t err = csplit(list, test_string, \" \"); // print the list of split fragments to stdout print_csplit_list_info(list, stdout); // print a separator printf(\"----------------------------\\n\"); // demo of getting fragment string at an index, 3 index will give us \"you\" char* test_get_index = get_fragment_at_index(list, 3); // demo of getting fragment string using reverse index, -1 will give us the last // fragment, in this case \"doing?\" char* test_get_r_index = get_fragment_at_index(list, -1); // print results printf(\"Get index: %s\\n\", test_get_index); printf(\"Get reverse index: %s\\n\", test_get_r_index); // free memory csplit_clear_list(list); } Output from running the above basic example: jwlodek@HP-Z6-G4-Workstation:~/Documents/csplit/examples$ ./basic_csplit_example Our demo string is: Hello how are you doing? List contains 5 elements Supports indexes -5 to 4. --Hello-- --how-- --are-- --you-- --doing?-- ---------------------------- Get index: you Get reverse index: doing? .csv reading example Example of using csplit to read .csv files. // include csplit and stdio #include \"csplit.h\" #include <stdio.h> int main(int argc, char** argv){ // open the file, return if NULL FILE* csv_file = fopen(\"exampleFiles/test.csv\", \"r\"); if(csv_file == NULL){ printf(\"Failed to open file, exiting.\\n\"); return -1; } // buffer for reading from file char buffer[256]; while(fgets(buffer, 256, csv_file)) { // ignore lines that are blank if(strlen(buffer) > 1){ // initialize the list, strip whitespace, and call csplit on commas CSplitList_t* list = csplit_init_list(); char* temp = csplit_strip(buffer); CSplitError_t err = csplit(list, temp, \",\"); free(temp); /* Make sure to free stripped line */ // print the split values print_csplit_list_info(list, stdout); // example iterating through resulting list and summing values read from .csv file CSplitFragment_t* current_fragment = list->head; int sum = 0; while(current_fragment != NULL){ sum = sum + atoi(current_fragment->text); current_fragment = current_fragment->next; } // print sum of numbers in line, and free memory printf(\"The sum of the elements in the line = %d\\n\", sum); csplit_clear_list(list); printf(\"----------------------\\n\"); } } fclose(csv_file); return 0; } When run on input file: jwlodek@HP-Z6-G4-Workstation:~/Documents/csplit/examples$ more exampleFiles/test.csv 5,6,2,4,9 3,0,1,4,2 2,7,2,1 3,8,4,7,10,1,3 The above example produces the following output: jwlodek@HP-Z6-G4-Workstation:~/Documents/csplit/examples$ ./reading_csv_example List contains 5 elements Supports indexes -5 to 4. --5-- --6-- --2-- --4-- --9-- The sum of the elements in the line = 26 ---------------------- List contains 5 elements Supports indexes -5 to 4. --3-- --0-- --1-- --4-- --2-- The sum of the elements in the line = 10 ---------------------- List contains 4 elements Supports indexes -4 to 3. --2-- --7-- --2-- --1-- The sum of the elements in the line = 12 ---------------------- List contains 7 elements Supports indexes -7 to 6. --3-- --8-- --4-- --7-- --10-- --1-- --3-- The sum of the elements in the line = 36 ---------------------- Basic string operations example A simple example showing some additional string processing functions included with csplit #include \"csplit.h\" #include <stdio.h> int main(int argc, char** argv){ // init test string char* test_string = \"Hello how are you doing?\\n\\n\"; printf(\"Our demo string is: --%s--\\n\", test_string); // strip outermost whitespace (2 newlines) char* stripped_str = csplit_strip(test_string); printf(\"The stripped string is --%s--\\n\", stripped_str); printf(\"Note the disappeared newline characters.\\n\"); // startswith command int temp = csplit_startswith(test_string, \"Hello\"); if(temp == 0){ printf(\"The input started with 'Hello'\\n\"); } // endswith - will fail here because of newlines, but succeed on the stripped one. temp = csplit_endswith(test_string, \"doing?\"); if(temp == 0){ printf(\"The input string ended with 'doing?'\\n\"); } temp = csplit_endswith(stripped_str, \"doing?\"); if(temp == 0){ printf(\"After stripping away newlines, the string ends with 'doing?'\\n\"); } // remove all whitespace and print char* no_whitespace = csplit_remove_whitespace(test_string); printf(\"The input string without any whitespace: --%s--\\n\", no_whitespace); // free memory. free(stripped_str); free(no_whitespace); } If we run the above example, we get: jwlodek@HP-Z6-G4-Workstation:~/Documents/csplit/examples$ ./str_processing_example Our demo string is: --Hello how are you doing? -- The stripped string is --Hello how are you doing?-- Note the disappeared newline characters. The input started with 'Hello' After stripping away newlines, the string ends with 'doing?' The input string without any whitespace: --Hellohowareyoudoing?-- Custom configure example An example of using csplit to read a custom configuration file #include \"csplit.h\" #include <stdio.h> #include <string.h> int main(int argc, char** argv){ // open the file FILE* fp = fopen(\"exampleFiles/CONFIGURE\", \"r\"); if(fp == NULL){ printf(\"Couldn't open file.\\n\"); return -1; } // char arrays where we will store resulting config char install_path[32]; char build_utests[32]; char build_examples[32]; char line_buff[256]; while(fgets(line_buff, 256, fp)){ // use csplit and string functions to remove comments and empty lines if(csplit_startswith(line_buff, \"#\") != 0 && strlen(line_buff) > 1){ CSplitList_t* list = csplit_init_list(); // initialize list, strip of whitespace, and split on '=' character. char* temp = csplit_strip(line_buff); CSplitError_t err = csplit(list, temp, \"=\"); // free up the stripped string free(temp); // print some info printf(\"Found config line:\\n\"); csplit_print_list_info(list, stdout); // if we match one of our targets, copy the value (index 1) into the appropriate array if(csplit_startswith(csplit_get_fragment_at_index(list, 0), \"INSTALL_PATH\") == 0){ strncpy(install_path, csplit_get_fragment_at_index(list, 1), sizeof(install_path)); } else if(csplit_startswith(csplit_get_fragment_at_index(list, 0), \"INSTALL_UTESTS\") == 0){ strncpy(build_utests, csplit_get_fragment_at_index(list, 1), sizeof(build_utests)); } else if(csplit_startswith(csplit_get_fragment_at_index(list, 0), \"BUILD_EXAMPLES\") == 0){ strncpy(build_examples, csplit_get_fragment_at_index(list, 1), sizeof(build_examples)); } // free list memory csplit_clear_list(list); } } // close the file, print our results. fclose(fp); printf(\"Configuration read from CONFIGURE file is:\\n\"); printf(\"INSTALL_LOCATION: %s, INSTALL_UTESTS: %s, BUILD_EXAMPLES: %s\\n\", install_path, build_utests, build_examples); return 0; } If we run the example on a simple example CONFIGURE file: jwlodek@HP-Z6-G4-Workstation:~/Documents/csplit/examples$ ./read_configure_example Found config line: List contains 2 elements Supports indexes -2 to 1. --INSTALL_PATH-- --/home/username-- Found config line: List contains 2 elements Supports indexes -2 to 1. --INSTALL_UTESTS-- --YES-- Found config line: List contains 2 elements Supports indexes -2 to 1. --BUILD_EXAMPLES-- --NO-- Configuration read from CONFIGURE file is: INSTALL_LOCATION: /home/username, INSTALL_UTESTS: YES, BUILD_EXAMPLES: NO","title":"Examples"},{"location":"examples/#csplit-usage-examples","text":"To build csplit examples, enter the examples directory, and run: make clean all or make clean debug to have access to gdb debugging of the examples. This has been tested on linux, as well as on Windows with gcc and make included in MinGW.","title":"csplit Usage Examples"},{"location":"examples/#basic-example","text":"Example demonstrating using csplit for splitting string on single character and getting split fragments based on indexes. // include csplit and stdio #include \"csplit.h\" #include <stdio.h> int main(int argc, char** argv){ // our test string char* test_string = \"Hello how are you doing?\"; printf(\"Our demo string is: %s\\n\", test_string); // initialize our output list CSplitList_t* list = csplit_init_list(); // split on the \" \" (space) character CSplitError_t err = csplit(list, test_string, \" \"); // print the list of split fragments to stdout print_csplit_list_info(list, stdout); // print a separator printf(\"----------------------------\\n\"); // demo of getting fragment string at an index, 3 index will give us \"you\" char* test_get_index = get_fragment_at_index(list, 3); // demo of getting fragment string using reverse index, -1 will give us the last // fragment, in this case \"doing?\" char* test_get_r_index = get_fragment_at_index(list, -1); // print results printf(\"Get index: %s\\n\", test_get_index); printf(\"Get reverse index: %s\\n\", test_get_r_index); // free memory csplit_clear_list(list); } Output from running the above basic example: jwlodek@HP-Z6-G4-Workstation:~/Documents/csplit/examples$ ./basic_csplit_example Our demo string is: Hello how are you doing? List contains 5 elements Supports indexes -5 to 4. --Hello-- --how-- --are-- --you-- --doing?-- ---------------------------- Get index: you Get reverse index: doing?","title":"Basic Example"},{"location":"examples/#csv-reading-example","text":"Example of using csplit to read .csv files. // include csplit and stdio #include \"csplit.h\" #include <stdio.h> int main(int argc, char** argv){ // open the file, return if NULL FILE* csv_file = fopen(\"exampleFiles/test.csv\", \"r\"); if(csv_file == NULL){ printf(\"Failed to open file, exiting.\\n\"); return -1; } // buffer for reading from file char buffer[256]; while(fgets(buffer, 256, csv_file)) { // ignore lines that are blank if(strlen(buffer) > 1){ // initialize the list, strip whitespace, and call csplit on commas CSplitList_t* list = csplit_init_list(); char* temp = csplit_strip(buffer); CSplitError_t err = csplit(list, temp, \",\"); free(temp); /* Make sure to free stripped line */ // print the split values print_csplit_list_info(list, stdout); // example iterating through resulting list and summing values read from .csv file CSplitFragment_t* current_fragment = list->head; int sum = 0; while(current_fragment != NULL){ sum = sum + atoi(current_fragment->text); current_fragment = current_fragment->next; } // print sum of numbers in line, and free memory printf(\"The sum of the elements in the line = %d\\n\", sum); csplit_clear_list(list); printf(\"----------------------\\n\"); } } fclose(csv_file); return 0; } When run on input file: jwlodek@HP-Z6-G4-Workstation:~/Documents/csplit/examples$ more exampleFiles/test.csv 5,6,2,4,9 3,0,1,4,2 2,7,2,1 3,8,4,7,10,1,3 The above example produces the following output: jwlodek@HP-Z6-G4-Workstation:~/Documents/csplit/examples$ ./reading_csv_example List contains 5 elements Supports indexes -5 to 4. --5-- --6-- --2-- --4-- --9-- The sum of the elements in the line = 26 ---------------------- List contains 5 elements Supports indexes -5 to 4. --3-- --0-- --1-- --4-- --2-- The sum of the elements in the line = 10 ---------------------- List contains 4 elements Supports indexes -4 to 3. --2-- --7-- --2-- --1-- The sum of the elements in the line = 12 ---------------------- List contains 7 elements Supports indexes -7 to 6. --3-- --8-- --4-- --7-- --10-- --1-- --3-- The sum of the elements in the line = 36 ----------------------","title":".csv reading example"},{"location":"examples/#basic-string-operations-example","text":"A simple example showing some additional string processing functions included with csplit #include \"csplit.h\" #include <stdio.h> int main(int argc, char** argv){ // init test string char* test_string = \"Hello how are you doing?\\n\\n\"; printf(\"Our demo string is: --%s--\\n\", test_string); // strip outermost whitespace (2 newlines) char* stripped_str = csplit_strip(test_string); printf(\"The stripped string is --%s--\\n\", stripped_str); printf(\"Note the disappeared newline characters.\\n\"); // startswith command int temp = csplit_startswith(test_string, \"Hello\"); if(temp == 0){ printf(\"The input started with 'Hello'\\n\"); } // endswith - will fail here because of newlines, but succeed on the stripped one. temp = csplit_endswith(test_string, \"doing?\"); if(temp == 0){ printf(\"The input string ended with 'doing?'\\n\"); } temp = csplit_endswith(stripped_str, \"doing?\"); if(temp == 0){ printf(\"After stripping away newlines, the string ends with 'doing?'\\n\"); } // remove all whitespace and print char* no_whitespace = csplit_remove_whitespace(test_string); printf(\"The input string without any whitespace: --%s--\\n\", no_whitespace); // free memory. free(stripped_str); free(no_whitespace); } If we run the above example, we get: jwlodek@HP-Z6-G4-Workstation:~/Documents/csplit/examples$ ./str_processing_example Our demo string is: --Hello how are you doing? -- The stripped string is --Hello how are you doing?-- Note the disappeared newline characters. The input started with 'Hello' After stripping away newlines, the string ends with 'doing?' The input string without any whitespace: --Hellohowareyoudoing?--","title":"Basic string operations example"},{"location":"examples/#custom-configure-example","text":"An example of using csplit to read a custom configuration file #include \"csplit.h\" #include <stdio.h> #include <string.h> int main(int argc, char** argv){ // open the file FILE* fp = fopen(\"exampleFiles/CONFIGURE\", \"r\"); if(fp == NULL){ printf(\"Couldn't open file.\\n\"); return -1; } // char arrays where we will store resulting config char install_path[32]; char build_utests[32]; char build_examples[32]; char line_buff[256]; while(fgets(line_buff, 256, fp)){ // use csplit and string functions to remove comments and empty lines if(csplit_startswith(line_buff, \"#\") != 0 && strlen(line_buff) > 1){ CSplitList_t* list = csplit_init_list(); // initialize list, strip of whitespace, and split on '=' character. char* temp = csplit_strip(line_buff); CSplitError_t err = csplit(list, temp, \"=\"); // free up the stripped string free(temp); // print some info printf(\"Found config line:\\n\"); csplit_print_list_info(list, stdout); // if we match one of our targets, copy the value (index 1) into the appropriate array if(csplit_startswith(csplit_get_fragment_at_index(list, 0), \"INSTALL_PATH\") == 0){ strncpy(install_path, csplit_get_fragment_at_index(list, 1), sizeof(install_path)); } else if(csplit_startswith(csplit_get_fragment_at_index(list, 0), \"INSTALL_UTESTS\") == 0){ strncpy(build_utests, csplit_get_fragment_at_index(list, 1), sizeof(build_utests)); } else if(csplit_startswith(csplit_get_fragment_at_index(list, 0), \"BUILD_EXAMPLES\") == 0){ strncpy(build_examples, csplit_get_fragment_at_index(list, 1), sizeof(build_examples)); } // free list memory csplit_clear_list(list); } } // close the file, print our results. fclose(fp); printf(\"Configuration read from CONFIGURE file is:\\n\"); printf(\"INSTALL_LOCATION: %s, INSTALL_UTESTS: %s, BUILD_EXAMPLES: %s\\n\", install_path, build_utests, build_examples); return 0; } If we run the example on a simple example CONFIGURE file: jwlodek@HP-Z6-G4-Workstation:~/Documents/csplit/examples$ ./read_configure_example Found config line: List contains 2 elements Supports indexes -2 to 1. --INSTALL_PATH-- --/home/username-- Found config line: List contains 2 elements Supports indexes -2 to 1. --INSTALL_UTESTS-- --YES-- Found config line: List contains 2 elements Supports indexes -2 to 1. --BUILD_EXAMPLES-- --NO-- Configuration read from CONFIGURE file is: INSTALL_LOCATION: /home/username, INSTALL_UTESTS: YES, BUILD_EXAMPLES: NO","title":"Custom configure example"},{"location":"functions/","text":"csplit.h External Functions csplit CSplitError_t csplit(CSplitList_t* list, char* input_str, char* token); Top level csplit function call. Outputs a csplit list split on a string token. Calls csplit_lim with max_splits = len(input_str), ensuring that all possible splits will be made. Params: [out]: list -> output list splitting input str on string token [in]: input_str -> input string which will be split [in]: token -> string on which to split Returns: err -> error code if there was a problem with csplitting. csplit_lim CSplitError_t csplit_lim(CSplitList_t* list, char* input_str, char* token, int max_splits); Function that allows user to split based on a limited number of splits, either forward or in reverse. A max_splits >= len(input_str) will guarantee all possible splits Params: [out]: list -> output list splitting input str on string token [in]: input_str -> input string which will be split [in]: token -> string on which to split [in]: max_splits -> max number of splits to perform. Negative if starting from end of string. Returns: err -> error code if there was a problem with csplitting. csplit_init_list CSplitList_t* csplit_init_list(); Function for initializing a csplit list Params: [in]: buff_size -> user set buffer size. Make sure this is large enough for your largest fragment Returns: list -> an allocated csplit list csplit_clear_list void csplit_clear_list(CSplitList_t* list); Clears all memory for an allocated csplit list Params: [in]: list -> a previously allocated csplit list to be freed csplit_print_list_info void csplit_print_list_info(CSplitList_t* list, FILE* fp); Function that prints information about a csplit list Params: [in]: list -> list for which to print info [in]: fp -> file pointer to print into. csplit_get_fragment_at_index char* csplit_get_fragment_at_index(CSplitList_t* list, int index); Function that returns the string fragment at a certain index in the list Params: [in]: list -> list generated by csplit [in]: index -> index to search for (can be negative for getting at index from back of list) Returns: text -> string at the given index or NULL if index out of range. csplit_reverse_list CSplitError_t csplit_reverse_list(CSplitList_t* list); Function that reverses the list generated by csplit Params: [out]: list -> list to reverse Returns: err -> error code if there is an error csplit_strip char* csplit_strip(char* input_str); Function that strips a given string into an output string. Will remove whitespace character: * \\n, \\r, \\t, space will be removed from the start and end of each string. Params: [in]: input_str -> the input string to strip Returns: output_str -> the string with whitespace removed from the ends. Must be freed. csplit_remove_whitespace char* csplit_remove_whitespace(char* input_str); Function that removes all whitespace characters of a given string into an output string. * Note that resulting char* must be free'd after it is no longer used Params: [in]: input_str -> the input string to strip Returns: output_str -> the string with whitespace removed. csplit_startswith int csplit_startswith(char* input_str, char* starts_with); Function that checks if a given string starts with another given string. Params: [in]: input_str -> string to check against [in]: starts_with -> string to try to match with start of input string Returns: int -> -2 if input is invalid, -1 if doesn't start with given string, or 0 if it does csplit_endswith int csplit_endswith(char* input_str, char* ends_with); Function that checks if a given string ends with another given string. Params: [in]: input_str -> string to check against [in]: ends_with -> string to try to match with end of input string Returns: int -> -2 if input is invalid, -1 if doesn't end with given string, or 0 if it does rcsplit CSplitError_t rcsplit(CSplitList_t* output_list, char* input_str, char* token); Function that runs csplit and then reverses the output. Params: [out]: output_list -> output list splitting input str on string token [in]: input_str -> input string which will be split [in]: token -> string on which to split Returns: err -> error code if there was a problem with csplitting. csplit.h Internal Functions These functions are used internally by the csplit library, and it is not recommended to use them outside of this internal context. csplit_push_to_list CSplitError_t csplit_push_to_list(CSplitList_t* list, CSplitFragment_t* fragment, size_t buff_size); Function that pushes a new CSplitFragment to the end of the list, and allocates memory for the text Params: [out]: list -> The list with fragment appended to the tail [in]: fragment -> fragment to append to the list. fragment->text will be allocated csplit_rstr CSplitError_t csplit_rstr(CSplitList_t* list, char* input_str, char* token, int max_splits); Function that runs csplit on a particular string from the end of the input. Called if max_splits < 0 Params: [out]: list -> split input string into this list structure [in]: input_str -> input string [in]: token -> character on which to split [in]: max_splits -> maximum number of splits. If negative will split from end of string Returns: err -> error code if there was a problem with csplitting. csplit_str CSplitError_t csplit_str(CSplitList_t* list, char* input_str, char* token, int max_splits); Function that splits a given input string based on another string. Params: [out]: list -> output list splitting input str on string token [in]: input_str -> input string which will be split [in]: token -> string on which to split [in]: max_splits -> max number of splits to perform. Negative if starting from end of string. Returns: err -> error code if there was a problem with csplitting.","title":"Functions"},{"location":"functions/#csplith-external-functions","text":"","title":"csplit.h External Functions"},{"location":"functions/#csplit","text":"CSplitError_t csplit(CSplitList_t* list, char* input_str, char* token); Top level csplit function call. Outputs a csplit list split on a string token. Calls csplit_lim with max_splits = len(input_str), ensuring that all possible splits will be made. Params: [out]: list -> output list splitting input str on string token [in]: input_str -> input string which will be split [in]: token -> string on which to split Returns: err -> error code if there was a problem with csplitting.","title":"csplit"},{"location":"functions/#csplit_lim","text":"CSplitError_t csplit_lim(CSplitList_t* list, char* input_str, char* token, int max_splits); Function that allows user to split based on a limited number of splits, either forward or in reverse. A max_splits >= len(input_str) will guarantee all possible splits Params: [out]: list -> output list splitting input str on string token [in]: input_str -> input string which will be split [in]: token -> string on which to split [in]: max_splits -> max number of splits to perform. Negative if starting from end of string. Returns: err -> error code if there was a problem with csplitting.","title":"csplit_lim"},{"location":"functions/#csplit_init_list","text":"CSplitList_t* csplit_init_list(); Function for initializing a csplit list Params: [in]: buff_size -> user set buffer size. Make sure this is large enough for your largest fragment Returns: list -> an allocated csplit list","title":"csplit_init_list"},{"location":"functions/#csplit_clear_list","text":"void csplit_clear_list(CSplitList_t* list); Clears all memory for an allocated csplit list Params: [in]: list -> a previously allocated csplit list to be freed","title":"csplit_clear_list"},{"location":"functions/#csplit_print_list_info","text":"void csplit_print_list_info(CSplitList_t* list, FILE* fp); Function that prints information about a csplit list Params: [in]: list -> list for which to print info [in]: fp -> file pointer to print into.","title":"csplit_print_list_info"},{"location":"functions/#csplit_get_fragment_at_index","text":"char* csplit_get_fragment_at_index(CSplitList_t* list, int index); Function that returns the string fragment at a certain index in the list Params: [in]: list -> list generated by csplit [in]: index -> index to search for (can be negative for getting at index from back of list) Returns: text -> string at the given index or NULL if index out of range.","title":"csplit_get_fragment_at_index"},{"location":"functions/#csplit_reverse_list","text":"CSplitError_t csplit_reverse_list(CSplitList_t* list); Function that reverses the list generated by csplit Params: [out]: list -> list to reverse Returns: err -> error code if there is an error","title":"csplit_reverse_list"},{"location":"functions/#csplit_strip","text":"char* csplit_strip(char* input_str); Function that strips a given string into an output string. Will remove whitespace character: * \\n, \\r, \\t, space will be removed from the start and end of each string. Params: [in]: input_str -> the input string to strip Returns: output_str -> the string with whitespace removed from the ends. Must be freed.","title":"csplit_strip"},{"location":"functions/#csplit_remove_whitespace","text":"char* csplit_remove_whitespace(char* input_str); Function that removes all whitespace characters of a given string into an output string. * Note that resulting char* must be free'd after it is no longer used Params: [in]: input_str -> the input string to strip Returns: output_str -> the string with whitespace removed.","title":"csplit_remove_whitespace"},{"location":"functions/#csplit_startswith","text":"int csplit_startswith(char* input_str, char* starts_with); Function that checks if a given string starts with another given string. Params: [in]: input_str -> string to check against [in]: starts_with -> string to try to match with start of input string Returns: int -> -2 if input is invalid, -1 if doesn't start with given string, or 0 if it does","title":"csplit_startswith"},{"location":"functions/#csplit_endswith","text":"int csplit_endswith(char* input_str, char* ends_with); Function that checks if a given string ends with another given string. Params: [in]: input_str -> string to check against [in]: ends_with -> string to try to match with end of input string Returns: int -> -2 if input is invalid, -1 if doesn't end with given string, or 0 if it does","title":"csplit_endswith"},{"location":"functions/#rcsplit","text":"CSplitError_t rcsplit(CSplitList_t* output_list, char* input_str, char* token); Function that runs csplit and then reverses the output. Params: [out]: output_list -> output list splitting input str on string token [in]: input_str -> input string which will be split [in]: token -> string on which to split Returns: err -> error code if there was a problem with csplitting.","title":"rcsplit"},{"location":"functions/#csplith-internal-functions","text":"These functions are used internally by the csplit library, and it is not recommended to use them outside of this internal context.","title":"csplit.h Internal Functions"},{"location":"functions/#csplit_push_to_list","text":"CSplitError_t csplit_push_to_list(CSplitList_t* list, CSplitFragment_t* fragment, size_t buff_size); Function that pushes a new CSplitFragment to the end of the list, and allocates memory for the text Params: [out]: list -> The list with fragment appended to the tail [in]: fragment -> fragment to append to the list. fragment->text will be allocated","title":"csplit_push_to_list"},{"location":"functions/#csplit_rstr","text":"CSplitError_t csplit_rstr(CSplitList_t* list, char* input_str, char* token, int max_splits); Function that runs csplit on a particular string from the end of the input. Called if max_splits < 0 Params: [out]: list -> split input string into this list structure [in]: input_str -> input string [in]: token -> character on which to split [in]: max_splits -> maximum number of splits. If negative will split from end of string Returns: err -> error code if there was a problem with csplitting.","title":"csplit_rstr"},{"location":"functions/#csplit_str","text":"CSplitError_t csplit_str(CSplitList_t* list, char* input_str, char* token, int max_splits); Function that splits a given input string based on another string. Params: [out]: list -> output list splitting input str on string token [in]: input_str -> input string which will be split [in]: token -> string on which to split [in]: max_splits -> max number of splits to perform. Negative if starting from end of string. Returns: err -> error code if there was a problem with csplitting.","title":"csplit_str"},{"location":"install/","text":"Installation Because csplit is a single-header library, all you need to do to use it for your projects is to copy the csplit.h file into your project location, and include it at the top of your source file in which you would like to use it. Clone this repository with: git clone https://github.com/jwlodek/csplit Then copy csplit.h into your repository, add the #include \"csplit.h\" line at the top of your code, and, if necessary, update your project's include path. Once you have compiled your project the csplit.h file is no longer needed as it has been compiled into your binary. Running Unit Tests Unit testing for csplit is done with the help of the Criterion library. To simplify setup, scripts have been added to the tests/ directory that setup this libarary, and run the tests. Simply run: cd tests ./initUnitTests.sh to initialize the Criterion Library, and then ./runUnitTests.sh to run the tests. Note that this only works on linux systems, and on windows you must set up the unit testing environment manually. To do this, you will have to download a Criterion binary release, then add it to your library/include path for Visual Studio/MinGW as appropriate. Then you will need to build the unit tests either with gcc + make via the included Makefile , or with Visual Studio. Once the test file has been built, it can be executed by running: ./csplit_core_tests Building Examples In order to build the examples included with csplit, you will need gcc and make installed on your system. Run the following commands: cd examples make clean all if you wish to build the examples in release mode. Alternatively, cd examples make clean debug will compile the examples with gdb debugging enabled.","title":"Installation"},{"location":"install/#installation","text":"Because csplit is a single-header library, all you need to do to use it for your projects is to copy the csplit.h file into your project location, and include it at the top of your source file in which you would like to use it. Clone this repository with: git clone https://github.com/jwlodek/csplit Then copy csplit.h into your repository, add the #include \"csplit.h\" line at the top of your code, and, if necessary, update your project's include path. Once you have compiled your project the csplit.h file is no longer needed as it has been compiled into your binary.","title":"Installation"},{"location":"install/#running-unit-tests","text":"Unit testing for csplit is done with the help of the Criterion library. To simplify setup, scripts have been added to the tests/ directory that setup this libarary, and run the tests. Simply run: cd tests ./initUnitTests.sh to initialize the Criterion Library, and then ./runUnitTests.sh to run the tests. Note that this only works on linux systems, and on windows you must set up the unit testing environment manually. To do this, you will have to download a Criterion binary release, then add it to your library/include path for Visual Studio/MinGW as appropriate. Then you will need to build the unit tests either with gcc + make via the included Makefile , or with Visual Studio. Once the test file has been built, it can be executed by running: ./csplit_core_tests","title":"Running Unit Tests"},{"location":"install/#building-examples","text":"In order to build the examples included with csplit, you will need gcc and make installed on your system. Run the following commands: cd examples make clean all if you wish to build the examples in release mode. Alternatively, cd examples make clean debug will compile the examples with gdb debugging enabled.","title":"Building Examples"}]}